package scala.scalanative
package runtime

import scala.scalanative.native._
import scala.scalanative.runtime.Atomic._

abstract class CAtomic {

  import CAtomicsImplicits._

}

%{
   classes = ['Byte', 'Short', 'Int', 'Long',
            'UnsignedByte', 'UnsignedShort', 'UnsignedInt',
             'UnsignedLong', 'Char', 'UnsignedChar', 'CSize']

   types = ['Byte', 'CShort', 'CInt', 'CLong',
            'Byte', 'CUnsignedShort', 'CUnsignedInt', 'CUnsignedLong',
            'CChar', 'CUnsignedChar', 'CSize']

   names = ['byte', 'short', 'int', 'long',
            'ubyte', 'ushort', 'uint', 'ulong',
            'char', 'uchar', 'csize']
}%

% for (C, T, N) in zip(classes, types, names):

%{
   default = '0' if N in ['int'] else ('\'a\'.asInstanceOf['+T+']' if N in ['char', 'uchar'] else '0.asInstanceOf['+T+']')
   cast = '' if N in ['byte', 'ubyte'] else '.cast[Ptr['+T+']]'
   castB = '' if N in ['byte', 'ubyte'] else '.cast[Ptr[Byte]]'
}%

class CAtomic${C}(default: ${T} = ${default}) extends CAtomic {

  private[this] val atm = stdlib.malloc(sizeof[${T}])${cast}
  init_${N}(atm, default)

  def load(): ${T} = load_${N}(atm)

  def store(value: ${T}): Unit = store_${N}(atm, value)

  def free(): Unit = stdlib.free(atm${castB})

  def compareAndSwapStrong(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr = stackalloc[${T}]
    !expectedPtr = expected

    if (compare_and_swap_strong_${N}(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def compareAndSwapWeak(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr = stackalloc[${T}]
    !expectedPtr = expected

    if (compare_and_swap_weak_${N}(atm, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def addFetch(value: ${T}): ${T} = {
    fetchAdd(value)
    load()
  }

  def fetchAdd(value: ${T}): ${T} = atomic_add_${N}(atm, value)

  def subFetch(value: ${T}): ${T} = {
    fetchSub(value)
    load()
  }

  def fetchSub(value: ${T}): ${T} = atomic_sub_${N}(atm, value)

  def andFetch(value: ${T}): ${T} = {
    fetchAnd(value)
    load()
  }

  def fetchAnd(value: ${T}): ${T} = atomic_and_${N}(atm, value)

  def orFetch(value: ${T}): ${T} = {
    fetchOr(value)
    load()
  }

  def fetchOr(value: ${T}): ${T} = atomic_or_${N}(atm, value)

  def xorFetch(value: ${T}): ${T} = {
    fetchXor(value)
    load()
  }

  def fetchXor(value: ${T}): ${T} = atomic_xor_${N}(atm, value)

  override def toString: String = load().toString

  override def equals(that: Any): Boolean = that match {
    case o: CAtomic${C} => o.load() == load()
    case o: ${T} => load() == o
    case _ => false
  }

}

object CAtomic${C} extends CAtomic {

  def apply(initValue: ${T}) = new CAtomic${C}(initValue)

  def apply() = new CAtomic${C}()

}

% end

class CAtomicRef[T <: AnyRef](default: T = 0L.asInstanceOf[T]) extends CAtomicLong(default.asInstanceOf[Long]) {}

object CAtomicRef extends CAtomic {

  def apply[T <: AnyRef](initValue: T) = new CAtomicRef[T](initValue)

  def apply[T <: AnyRef]() = new CAtomicRef[T]()

}

// Helper object, can be imported for ease of use
object CAtomicsImplicits {

  implicit def toLong[T <: AnyRef](r: T): CLong = r.asInstanceOf[CLong]
  implicit def toRef[T <: AnyRef](l: CLong): T = l.asInstanceOf[T]
  implicit def underlying[T <: AnyRef](a: CAtomicRef[T]): T = a.load().asInstanceOf[T]
  implicit def cas[T](v: (Boolean, T)): Boolean = v._1
  %for (C, T) in zip(classes, types):
  implicit def underlying(a: CAtomic${C}): ${T} = a.load()
  %end

}

